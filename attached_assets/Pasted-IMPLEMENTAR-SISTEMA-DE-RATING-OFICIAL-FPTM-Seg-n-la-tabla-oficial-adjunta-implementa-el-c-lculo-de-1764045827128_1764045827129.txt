IMPLEMENTAR SISTEMA DE RATING OFICIAL FPTM

SegÃºn la tabla oficial adjunta, implementa el cÃ¡lculo de rating basado en la diferencia entre jugadores:

1. CREAR ARCHIVO: client/src/lib/ratingSystem.ts
```typescript
/**
 * Sistema de Rating Oficial FPTM
 * Basado en diferencia de rating entre jugadores
 */

interface RatingTable {
  minDiff: number;
  maxDiff: number;
  favoriteWins: number;    // Puntos si gana el favorito
  underdogWins: number;     // Puntos si gana el no favorito
}

// Tabla oficial FPTM
const RATING_TABLE: RatingTable[] = [
  { minDiff: 0,   maxDiff: 24,   favoriteWins: 8,  underdogWins: 8 },
  { minDiff: 25,  maxDiff: 49,   favoriteWins: 7,  underdogWins: 10 },
  { minDiff: 50,  maxDiff: 99,   favoriteWins: 5,  underdogWins: 12 },
  { minDiff: 100, maxDiff: 149,  favoriteWins: 3,  underdogWins: 15 },
  { minDiff: 150, maxDiff: 199,  favoriteWins: 2,  underdogWins: 20 },
  { minDiff: 200, maxDiff: 249,  favoriteWins: 1,  underdogWins: 26 },
  { minDiff: 250, maxDiff: 9999, favoriteWins: 0,  underdogWins: 32 }
];

interface Player {
  id: string;
  name: string;
  rating: number;
}

interface MatchResult {
  sets: Array<{ player1: number; player2: number }>;
  winner: string;
}

interface RatingChange {
  player1: {
    id: string;
    name: string;
    oldRating: number;
    change: number;
    newRating: number;
    isFavorite: boolean;
  };
  player2: {
    id: string;
    name: string;
    oldRating: number;
    change: number;
    newRating: number;
    isFavorite: boolean;
  };
  ratingDifference: number;
  appliedRow: RatingTable;
}

export function calculateRatingChange(
  player1: Player,
  player2: Player,
  result: MatchResult
): RatingChange {
  // Determinar quiÃ©n es el favorito (mayor rating)
  const isFavorite1 = player1.rating >= player2.rating;
  const favorite = isFavorite1 ? player1 : player2;
  const underdog = isFavorite1 ? player2 : player1;
  
  // Calcular diferencia absoluta
  const ratingDiff = Math.abs(player1.rating - player2.rating);
  
  // Buscar en la tabla
  const tableRow = RATING_TABLE.find(
    row => ratingDiff >= row.minDiff && ratingDiff <= row.maxDiff
  ) || RATING_TABLE[RATING_TABLE.length - 1];
  
  // Determinar ganador
  const favoriteWon = result.winner === favorite.id;
  
  // Calcular puntos base
  let favoriteChange: number;
  let underdogChange: number;
  
  if (favoriteWon) {
    favoriteChange = tableRow.favoriteWins;
    underdogChange = -tableRow.favoriteWins;
  } else {
    favoriteChange = -tableRow.underdogWins;
    underdogChange = tableRow.underdogWins;
  }
  
  // BONUS POR SETS (opcional, basado en implementaciÃ³n anterior)
  const setsWon = {
    player1: 0,
    player2: 0
  };
  
  result.sets.forEach(set => {
    if (set.player1 > set.player2) setsWon.player1++;
    else setsWon.player2++;
  });
  
  // Bonus si ganÃ³ 3-0
  const winner = result.winner;
  const winnerSets = winner === player1.id ? setsWon.player1 : setsWon.player2;
  const loserSets = winner === player1.id ? setsWon.player2 : setsWon.player1;
  
  let setBonus = 0;
  if (winnerSets === 3 && loserSets === 0) {
    setBonus = 2; // +2 puntos por victoria 3-0
  } else if (winnerSets === 3 && loserSets === 1) {
    setBonus = 1; // +1 punto por victoria 3-1
  }
  
  // Aplicar bonus al ganador
  if (result.winner === favorite.id) {
    favoriteChange += setBonus;
  } else {
    underdogChange += setBonus;
  }
  
  // Preparar resultado
  const player1Change = isFavorite1 ? favoriteChange : underdogChange;
  const player2Change = isFavorite1 ? underdogChange : favoriteChange;
  
  return {
    player1: {
      id: player1.id,
      name: player1.name,
      oldRating: player1.rating,
      change: player1Change,
      newRating: player1.rating + player1Change,
      isFavorite: isFavorite1
    },
    player2: {
      id: player2.id,
      name: player2.name,
      oldRating: player2.rating,
      change: player2Change,
      newRating: player2.rating + player2Change,
      isFavorite: !isFavorite1
    },
    ratingDifference: ratingDiff,
    appliedRow: tableRow
  };
}

// FunciÃ³n helper para formatear el cambio de rating
export function formatRatingChange(change: number): string {
  if (change > 0) return `+${change}`;
  return change.toString();
}

// FunciÃ³n helper para obtener color segÃºn cambio
export function getRatingChangeColor(change: number): string {
  if (change > 0) return 'text-green-600';
  if (change < 0) return 'text-red-600';
  return 'text-gray-600';
}
```

2. ACTUALIZAR handleApprove en /admin/verify-results:
```typescript
async function handleApprove(matchId: string) {
  try {
    const match = getMatch(matchId);
    
    // CALCULAR RATING CHANGE CON NUEVO SISTEMA
    const ratingChange = calculateRatingChange(
      match.player1,
      match.player2,
      match.result
    );
    
    // Actualizar match con status verified
    updateMatch(matchId, {
      status: 'verified',
      verifiedBy: currentUser.id,
      verifiedAt: new Date(),
      ratingChange: ratingChange // Guardar para referencia
    });
    
    // Actualizar ratings de jugadores
    updatePlayerRating(match.player1.id, ratingChange.player1.newRating);
    updatePlayerRating(match.player2.id, ratingChange.player2.newRating);
    
    // Toast mejorado con detalles
    toast.success(
      <div className="space-y-2">
        <div className="font-bold">âœ“ Resultado Aprobado</div>
        <div className="text-sm">
          <div>
            {ratingChange.player1.name}: 
            <span className={getRatingChangeColor(ratingChange.player1.change)}>
              {formatRatingChange(ratingChange.player1.change)} pts
            </span>
            ({ratingChange.player1.oldRating} â†’ {ratingChange.player1.newRating})
          </div>
          <div>
            {ratingChange.player2.name}: 
            <span className={getRatingChangeColor(ratingChange.player2.change)}>
              {formatRatingChange(ratingChange.player2.change)} pts
            </span>
            ({ratingChange.player2.oldRating} â†’ {ratingChange.player2.newRating})
          </div>
        </div>
        <div className="text-xs text-gray-600">
          Diferencia de rating: {ratingChange.ratingDifference} puntos
        </div>
      </div>
    );
    
  } catch (error) {
    toast.error('Error al aprobar resultado');
  }
}
```

3. MOSTRAR RATING CHANGE EN CARDS DE VERIFICACIÃ“N:

Actualizar el Card de partidos en /admin/verify-results para mostrar:
```tsx
{/* Preview de Cambio de Rating */}
<div className="bg-gradient-to-r from-blue-50 to-purple-50 p-4 rounded-lg mb-4">
  <div className="text-sm font-semibold mb-2 text-gray-700">
    ðŸ“Š Cambio de Rating Proyectado:
  </div>
  <div className="space-y-1">
    <div className="flex justify-between items-center">
      <span>{match.player1.name}</span>
      <span className={getRatingChangeColor(projectedChange.player1.change)}>
        {formatRatingChange(projectedChange.player1.change)} pts
        <span className="text-xs ml-2 text-gray-500">
          ({match.player1.rating} â†’ {projectedChange.player1.newRating})
        </span>
      </span>
    </div>
    <div className="flex justify-between items-center">
      <span>{match.player2.name}</span>
      <span className={getRatingChangeColor(projectedChange.player2.change)}>
        {formatRatingChange(projectedChange.player2.change)} pts
        <span className="text-xs ml-2 text-gray-500">
          ({match.player2.rating} â†’ {projectedChange.player2.newRating})
        </span>
      </span>
    </div>
  </div>
  <div className="text-xs text-gray-600 mt-2">
    Diferencia de rating: {projectedChange.ratingDifference} pts
    {projectedChange.player1.isFavorite 
      ? ` (${match.player1.name} es favorito)` 
      : ` (${match.player2.name} es favorito)`}
  </div>
</div>
```

4. ACTUALIZAR mockMatches CON RATINGS VARIADOS:

Para probar el sistema, crear matches con diferentes diferencias de rating:
```typescript
// Match con ratings similares (diff < 25)
{
  player1: { rating: 1850 },
  player2: { rating: 1840 }
  // Ganador: +8, Perdedor: -8
}

// Match con diferencia mediana (diff 50-99)
{
  player1: { rating: 1900 },
  player2: { rating: 1820 }
  // Si favorito gana: +5, -5
  // Si underdog gana: -12, +12
}

// Match con gran diferencia (diff 200+)
{
  player1: { rating: 2100 },
  player2: { rating: 1600 }
  // Si favorito gana: +1, -1
  // Si underdog gana: -26, +26 (Â¡GRAN UPSET!)
}
```

5. CREAR PÃGINA: /rankings con sorting dinÃ¡mico

Actualizar la pÃ¡gina de rankings para mostrar cambios recientes:
```tsx
<Table>
  <TableHeader>
    <TableRow>
      <TableHead>Pos</TableHead>
      <TableHead>Jugador</TableHead>
      <TableHead>Rating</TableHead>
      <TableHead>Cambio</TableHead>
      <TableHead>Partidos</TableHead>
      <TableHead>V-D</TableHead>
    </TableRow>
  </TableHeader>
  <TableBody>
    {rankedPlayers.map((player, index) => (
      <TableRow key={player.id}>
        <TableCell className="font-bold">{index + 1}</TableCell>
        <TableCell>
          <div className="flex items-center gap-2">
            <Avatar className="w-8 h-8">
              <AvatarImage src={player.photoURL} />
              <AvatarFallback>{player.initials}</AvatarFallback>
            </Avatar>
            <div>
              <div className="font-semibold">{player.name}</div>
              <div className="text-xs text-gray-500">{player.memberNumber}</div>
            </div>
          </div>
        </TableCell>
        <TableCell className="font-bold text-lg">{player.rating}</TableCell>
        <TableCell>
          {player.lastChange !== 0 && (
            <Badge variant={player.lastChange > 0 ? 'success' : 'destructive'}>
              {formatRatingChange(player.lastChange)}
            </Badge>
          )}
        </TableCell>
        <TableCell>{player.matchesPlayed}</TableCell>
        <TableCell>{player.wins}-{player.losses}</TableCell>
      </TableRow>
    ))}
  </TableBody>
</Table>
```

Implementa todo esto AHORA para tener el sistema oficial de rating FPTM funcionando.